---
title: Mocking
sidebar_position: 5
---

# Mocking

This Bats helper library provides command mocking functionality for BATS.

It allows to mock commands and check how they were called.

This is a very powerful feature that allows to test complex scenarios as unit
tests.

:::note

To run multiple mock assertions in a more convenient way, check out
the [step runner](step-runner) helper.

:::

## Acknowledgments

This functionality is based on the [bats-mock](https://github.com/grayhemp/bats-mock) project.
A special thank you to the contributors for their original work.

## Usage

```bash
setup() {
  setup_mock
}

# Example to test the notify.sh script that uses curl to send a notification to external system.
@test "Notify" {
  app_id="9876543210"

  # Mock curl command.
  mock_curl="$(mock_command "curl")"

  # Setup mock responses for curl call with specific arguments in notify.sh.
  mock_set_output "${mock_curl}" "12345678910-1234567890-${app_id}-12345" 1
  mock_set_output "${mock_curl}" "201" 2

  run ./notify.sh
  assert_success

  # Single line mock assertion example.
  assert_equal "-s -X GET https://api.example.com/v2/applications.json" "$(mock_get_call_args "${mock_curl}" 1)"
  # Multi-line mock assertion example.
  assert_equal '-X POST https://api.example.com/v2/applications/9876543210/deployments.json -d {
  "deployment": {
    "description": "example description",
  }
}' "$(mock_get_call_args "${mock_curl}" 2)"
}
```

## Setup functions

### `mock_create`

- **Description**: Creates a mock program that can be executed and tracked. Optionally creates a named command.
- **Arguments**:
  - Command name (optional) - If provided, creates a symbolic link with the given name
- **Global Variables**: Uses `BATS_MOCK_TMPDIR` if set, otherwise `BATS_TMPDIR`
- **Outputs**: Path to the created mock file or mocked command
- **Usage**:
  ```bash
  # Create unnamed mock
  mock=$(mock_create)

  # Create named mock command
  mock_wget=$(mock_create wget)
  ```

### `setup_mock`

Setup mock support. Call this function from your test's `setup()` method.

### `mock_command`

- **Description**: Mock provided command.
- **Arguments**:
  - Mocked command name
- **Outputs**: Path to created mock file.
- **Usage**:
  ```bash
  mock_command "ls"
  ```

### `mock_set_output`

- **Description**: Sets the output of the mock.
- **Arguments**:
  - Path to the mock
  - Output or `-` for STDIN
  - Index of the call (optional)
- **Usage**:
  ```bash
  mock_set_output "${mock}" "some output"
  ```

### `mock_set_status`

- **Description**: Sets the exit status of the mock.
- **Arguments**:
  - Path to the mock
  - Status
  - Index of the call (optional)
- **Usage**:
  ```bash
  mock_set_status "${mock}" 0
  ```

### `mock_set_side_effect`

- **Description**: Sets shell code to be executed when the mock runs.
- **Arguments**:
  - Path to the mock
  - Side effect (shell code) or `-` for STDIN
  - Index of the call (optional)
- **Usage**:
  ```bash
  mock_set_side_effect "${mock}" "echo 'side effect executed' > /tmp/log"
  ```

### `teardown_mock`

- **Description**: Cleans up all mock files and directories created during tests.
- **Arguments**: None
- **Global Variables**: Uses `BATS_MOCK_TMPDIR` if set, otherwise `BATS_TMPDIR`
- **Usage**:
  ```bash
  teardown() {
    teardown_mock
  }
  ```

## Deterministic Test Setup

These functions enable you to create isolated, deterministic test environments by manipulating the `PATH` variable and creating controlled command environments. This is particularly useful for negative testing scenarios where you need to test behavior when certain commands are unavailable.

### `mock_chroot`

- **Description**: Creates a directory populated with symbolic links to basic system commands. This provides a controlled environment for testing.
- **Arguments**:
  - List of commands (optional) - If provided, only creates links for specified commands. If not provided, creates links for a default set of common commands.
- **Returns**: Exit code 1 if a specified command cannot be found
- **Outputs**: Path to the chroot directory
- **Usage**:
  ```bash
  # Create chroot with default commands
  chroot_path=$(mock_chroot)

  # Create chroot with specific commands only
  chroot_path=$(mock_chroot cat ls grep)
  ```

:::note

`mock_create` with a command name and `mock_chroot` both place commands in the same directory (`bats-mock.$$.bin`), making them work seamlessly together.

:::

### `path_prefix`

- **Description**: Returns a PATH string with the mock directory prepended. This ensures mocked commands are found first.
- **Arguments**:
  - Path to mock/command/directory to prepend
  - PATH to modify (optional) - Defaults to `$PATH` if not provided
- **Outputs**: Modified PATH string
- **Usage**:
  ```bash
  mock_wget=$(mock_create wget)
  new_path=$(path_prefix "${mock_wget}")
  PATH="${new_path}" run ./script.sh
  ```

### `path_rm`

- **Description**: Returns a PATH string with a specific directory removed. Useful for testing command unavailability.
- **Arguments**:
  - Path or command to remove
  - PATH to modify (optional) - Defaults to `$PATH` if not provided
- **Outputs**: Modified PATH string
- **Usage**:
  ```bash
  # Remove /usr/bin from PATH
  new_path=$(path_rm /usr/bin)

  # Remove directory containing curl
  new_path=$(path_rm "$(command -v curl)")
  ```

### Example: Testing Command Fallback

This example demonstrates testing a script that falls back from `curl` to `wget` when `curl` is not available:

```bash
@test "Script falls back to wget when curl unavailable" {
  # Create mock wget
  mock_wget=$(mock_create wget)
  mock_set_output "${mock_wget}" "Downloaded successfully"

  # Create isolated environment without curl
  chroot_path=$(mock_chroot cat echo bash)
  test_path=$(path_prefix "${chroot_path}" "$(path_rm /usr/bin "$(path_rm /bin)")")

  # Run script in isolated environment
  PATH="${test_path}" run ./download-script.sh "http://example.com/file"

  assert_success
  assert_output_contains "Downloaded successfully"
  assert_equal 1 "$(mock_get_call_num "${mock_wget}")"
}
```

## Assertion functions

### `mock_get_call_args`

- **Description**: Returns the arguments line the mock was called with.
- **Arguments**:
  - Path to the mock
  - Index of the call (optional)
- **Outputs**: Arguments line
- **Usage**:
  ```bash
  assert_equal "expected_arg1 expected_arg2" "$(mock_get_call_args "${mock}" 1)"
  ```

### `mock_get_call_num`

- **Description**: Returns the number of times the mock was called.
- **Arguments**:
  - Path to the mock
- **Outputs**: Number of calls
- **Usage**:
  ```bash
  assert_equal "1" "$(mock_get_call_num "${mock}")"
  ```

### `mock_get_call_user`

- **Description**: Returns the user the mock was called with.
- **Arguments**:
  - Path to the mock
  - Index of the call (optional)
- **Outputs**: User name
- **Usage**:
  ```bash
  assert_equal "expected_user" "$(mock_get_call_user "${mock}" 1)"
  ```

### `mock_get_call_env`

- **Description**: Returns the value of the environment variable the mock was
  called with.
- **Arguments**:
  - Path to the mock
  - Variable name
  - Index of the call (optional)
- **Outputs**: Variable value
- **Usage**:
  ```bash
  assert_equal "expected_val1" "$(mock_get_call_env "${mock}" VAR_NAME 1)"
  ```
